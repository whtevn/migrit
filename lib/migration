#!/usr/bin/env node

var fs = require('q-io/fs')
  , Migration = {}
  ;


Migration.create = function(title, config){
  var timestamp = +(new Date)
    , filename  = timestamp+"_"+title.replace(/\s/g, "_")+".json"
    , filepath  = config.base+(config.migrations||'migrations')+'/'
    , migration = {
        author:      ""
      , description: title
      , created_at:  timestamp
      , up:   ['']
      , down: ['']
      }
    ;

    migration = JSON.stringify(migration, null, "\t");

    fs.isDirectory(filepath)
      .then(function(is_directory){
        if(!is_directory){
          return fs.makeDirectory(filepath);
        }
      })
      .then(function(){
        fs.write(filepath+filename, migration)
        .then(function(res){
          console.log(filepath+filename+" has been written");
        });
    });
}

Migration.runSet = function (max, state, migrations){
  if(migrations && migrations.length==0){
    // end execution if there are no more migrations to run
    console.log('finished');
    return true
  }

  // get the current database state
  var timestamp
    , skip
    , file = migrations.shift()
    ;

  // look at each migration file under the given path
  return fs.isFile(file)
    .then(function(is_file){
      if(is_file && !file.match(/\/\.[^\/]*$/)){
        // get the timestamp of the migration file
        timestamp = +(file.match(/\/(\d*)_.*$/)[1]);

        // if the path being examined is a file, and the timestamp
        // is under the given maximum, or there is no given maximum
        if(timestamp <= max || !max){
          if(timestamp <= state){
            skip = 'exists'.grey
          }
        }else{
          skip = 'skipped'.grey
        }

        return Migration.run(file, timestamp, skip);
      }
    })
    .then(function(){
      return Migration.runSet(max, state, migrations);
    });
}

Migration.run = function(file, timestamp, skip){
  return fs.read(file)
    .then(function(migration){
      migration = JSON.parse(migration);
      console.log((skip||'running'.magenta), timestamp.toString().cyan, migration.description.green);

      return Migration.sql.batch(timestamp, migration[Migration.direction], skip)
    });
}
module.exports = Migration; 
