#!/usr/bin/env node

var up        = require('../lib/up')
  , down      = require('../lib/down') 
  , Migration = require('../lib/migration')
  , exporter  = require('../lib/export_fixtures').generate
  , importer  = require('../lib/import_fixtures').print
  , sql       = require('../lib/sql')
  , prompt    = require('prompt')
  , args      = require('yargs')
  , argv      = args.argv
  , fs        = require('q-io/fs')
  , q         = require('q')
  , config    = findConfig('.')
  , additive
  ;

prompt.message = '';
prompt.delimiter = '';


// recursively search for a config file
// could abstract this out into its own package
// will be useful for deploy tool
function findConfig(level){
  // check to see if the level we are at is a directory
  return fs.isDirectory(level)
    .then(function(is_directory){
      var dir_options = ['/.migrit.json', '/migrit.json', '/etc/migrit.json', '/etc/.migrit.json'];
      if(is_directory){
        // make an array of promises to return whether or not each option is a file on this level
        is_file = dir_options.map(function(opt){
          // check to see if any of the options for a migrit.json file exist on this level
          return fs.isFile(level+opt);
        });

        return q.all(is_file)
          .then(function(is_file){
            // if any of this options are found on this level, return the location of the file
            // locate the working dir_option by finding the first place the is_file array is `true`
            // it is possible to find more than one migrit.json file is found, but they will be loaded
            // by preference according to the order of the array
            return level+dir_options[is_file.indexOf(true)];
          });
      }else{
        // otherwise, throw an error
        throw('no config file found'); 
      }
    })
    .then(function(is_file){
      if(is_file){
        // if the file was found
        return fs.read(is_file)
          .then(function(contents){
            contents = JSON.parse(contents); 
            contents.base = is_file.replace(/\.?migrit.json/, '');
            contents.state_table = contents.state_table||'database_state';
            contents.state_field = contents.state_field||'timestamp';
            contents.migrations  = contents.migrations||'migrations'
            contents.fixtures    = contents.fixtures||'fixtures'
            return contents;
          });
      }else{
        // if no file was found, try one level higher
        return findConfig(level+'/..');
      }
    })
    .fail(function(err){
      // console log any errors
      console.log(err);
    });
}

// the first command line option tells which sub-program is being run

// accept other command line arguments and delegate to sub-programs as necessary

config.then(function(c){
  var title
    , schema
    ;

  switch(argv._[0]){
    case undefined:
      argv = args
        .usage("Usage: $0 --title 'title for migration'")
        .alias('t', 'title')
        .describe('t', 'title for the migration')
        .argv;
      try{
        prompt.override = args.argv;
        prompt.start();

        schema = {
          properties: {
            t: {
              message: 'What will this migration be doing?'.green
            , required: true
            }
          }
        }

        prompt.get(schema, function(err, result){
          Migration.create(result.t, c);
        });
      }catch(err){
        console.log(err);
      }
      break;
    case 'up':
      argv = args
        .usage("Usage: $0 up --max 12345 --database connection_name")
        .alias('m', 'max')
        .alias('d', 'database')
        .alias('n', 'num')
        .default('m', false)
        .default('d', 'local')
        .describe('n', 'number of migrations to run down from current location')
        .describe('m', 'maximum migration to run')
        .describe('d', 'database connection name')
        .argv;

        if(argv.n){
          sql.connect(c, argv.d)

          q.all([
            sql.getDBState()
          , Migration.getSet(c)])
          .then(function(promises){
              var state = promises[0]
                , migrations = promises[1]
                , current = migrations.indexOf(state)
                , advance = argv.n
                , to_state = migrations[current+advance]
                ;
              return up(c, argv.d, to_state);
            })
            .catch(function(err){
              console.log(err);
              console.log(err.stack);
            })
        }else{
          up(c, argv.d, argv.m);
        }
      break;
    case 'down':
      argv = args
        .usage("Usage: $0 down --max 12345 --database connection_name")
        .alias('m', 'min')
        .alias('d', 'database')
        .alias('n', 'num')
        .default('m', 0)
        .default('d', 'local')
        .describe('n', 'number of migrations to run down from current location')
        .describe('m', 'minimum migration to run')
        .describe('d', 'database connection name')
        .argv;

        if(argv.n){
          sql.connect(c, argv.d)

          q.all([
            sql.getDBState()
          , Migration.getSet(c)])
          .then(function(promises){
              var state = promises[0]
                , migrations = promises[1]
                , current = migrations.indexOf(state)
                , advance = argv.n
                , to_state = migrations[current-advance]
                ;
              
              return down(c, argv.d, to_state);
            })
            .catch(function(err){
              console.log(err);
              console.log(err.stack);
            })
        }else{
          down(c, argv.d, argv.m);
        }

      break;
    case 'export':
      argv = args
        .usage("Usage: $0 export --fixture set_name --database connection_name")
        .alias('f', 'fixture')
        .alias('d', 'database')
        .default('f', 'default')
        .default('d', 'local')
        .describe('f', 'name of fixture set')
        .describe('d', 'database connection name')
        .argv;
      exporter(c, argv.d, argv.f);
      break;
    case 'import':
      argv = args
        .usage("Usage: $0 import --fixture set_name --database connection_name")
        .alias('a', 'add')
        .alias('f', 'fixture')
        .alias('d', 'database')
        .default('f', 'default')
        .default('d', 'testing')
        .describe('f', 'name of fixture set')
        .describe('d', 'database connection name')
        .argv;
      additive = argv.a;
      importer(c, argv.d, argv.f, additive);
      break;
    default:
      console.log('show help');
      break; 
  }
});
